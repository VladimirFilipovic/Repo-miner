import * as fs from "fs";
import * as natural from "natural";
import jaroWinkler from "jaro-winkler";
import nlp from "compromise";

interface KeywordDictionary {
  [category: string]: string[];
}

interface RepositoryComments {
  [repoName: string]: string;
}

interface RepositoryResults {
  [repoName: string]: {
    assignedCategory: string;
    categoryScores: { [category: string]: number };
  };
}

const keywords2: KeywordDictionary = {
  "General Quantum Algorithms": [
    "algorithm",
    "search",
    "walk",
    "Fourier transform",
    "phase estimation",
    "hidden subgroup problem",
    "speedup",
    "optimization",
    "teleportation",
    "アルゴリズム",
    "検索",
    "ウォーク",
    "フーリエ変換",
    "位相推定",
    "隠れ部分群問題",
    "スピードアップ",
    "最適化",
    "テレポーテーション",
    "算法",
    "搜索",
    "行走",
    "傅里叶变换",
    "相位估计",
    "隐藏子群问题",
    "加速",
    "优化",
    "量子传送",
  ],
  // Add other categories similarly...
};

const keywords: KeywordDictionary = {
  "General Quantum Algorithms": [
    "algorithm",
    "search",
    "walk",
    "Fourier transform",
    "phase estimation",
    "hidden subgroup problem",
    "speedup",
    "optimization",
    "teleportation",
    "アルゴリズム",
    "検索",
    "ウォーク",
    "フーリエ変換",
    "位相推定",
    "隠れ部分群問題",
    "スピードアップ",
    "最適化",
    "テレポーテーション",
    "算法",
    "搜索",
    "行走",
    "傅里叶变换",
    "相位估计",
    "隐藏子群问题",
    "加速",
    "优化",
    "量子传送",
  ],
  "Grover's Algorithm": [
    "grover",
    "amplitude amplification",
    "search",
    "algorithm",
    "グローバー",
    "振幅増幅",
    "検索",
    "アルゴリズム",
    "格罗夫",
    "幅值放大",
    "搜索",
    "算法",
  ],
  "Shor's Algorithm": [
    "shor",
    "algorithm",
    "shor's algorithm",
    "fraction",
    "fractals",
    "factorization",
    "integer factorization",
    "period finding",
    "order finding",
    "discrete logarithm",
    "RSA",
    "elliptic curve",
    "cryptography",
    "safe",
    "resistant",
    "ショア",
    "アルゴリズム",
    "ショアのアルゴリズム",
    "分数",
    "フラクタル",
    "因数分解",
    "整数因数分解",
    "周期探索",
    "順序探索",
    "離散対数",
    "楕円曲線",
    "暗号",
    "安全",
    "耐性",
    "肖尔",
    "算法",
    "肖尔算法",
    "分数",
    "分形",
    "因数分解",
    "整数因数分解",
    "周期发现",
    "序列发现",
    "离散对数",
    "RSA",
    "椭圆曲线",
    "密码学",
    "安全",
    "抗性",
  ],
  "Variational Quantum Eigensolver (VQE)": [
    "variational eigensolver",
    "algorithm",
    "vqe",
    "chemistry",
    "変分固有値求解器",
    "アルゴリズム",
    "vqe",
    "化学",
    "变分特征值求解器",
    "算法",
    "vqe",
    "化学",
  ],
  "Quantum Approximate Optimization Algorithm (QAOA)": [
    "approximate optimization algorithm",
    "qaoa",
    "optimization",
    "algorithm",
    "maxcut",
    "traveling salesman",
    "tsp",
    "combinatorial optimization",
    "graph partitioning",
    "scheduling",
    "routing",
    "近似最適化アルゴリズム",
    "qaoa",
    "最適化",
    "アルゴリズム",
    "最大カット",
    "巡回セールスマン",
    "tsp",
    "組合せ最適化",
    "グラフ分割",
    "スケジューリング",
    "ルーティング",
    "近似优化算法",
    "qaoa",
    "优化",
    "算法",
    "最大割",
    "旅行推销员",
    "tsp",
    "组合优化",
    "图划分",
    "调度",
    "路由",
  ],
  "HHL Algorithm": [
    "hhl algorithm",
    "linear systems",
    "matrix inversion",
    "algorithm",
    "hhlアルゴリズム",
    "線形システム",
    "行列反転",
    "アルゴリズム",
    "hhl算法",
    "线性系统",
    "矩阵求逆",
    "算法",
  ],
  "Deutsch-Jozsa Algorithm": [
    "deutsch-jozsa",
    "balanced function",
    "algorithm",
    "ドイチョジョーザ",
    "バランス関数",
    "アルゴリズム",
    "德意志-乔萨",
    "平衡函数",
    "算法",
  ],
  "Simon's Algorithm": [
    "simon",
    "simon’s algorithm",
    "periodicity",
    "hidden period",
    "algorithm",
    "サイモン",
    "サイモンのアルゴリズム",
    "周期性",
    "隠れた周期",
    "アルゴリズム",
    "西蒙",
    "西蒙算法",
    "周期性",
    "隐藏周期",
    "算法",
  ],
  "General Quantum Cryptography": [
    "security",
    "cryptography",
    "encryption",
    "secure direct communication",
    "post-cryptography",
    "network",
    "repeater",
    "hacking",
    "side-channel attack",
    "bit commitment",
    "digital signatures",
    "secret sharing",
    "secure comunication",
    "safe",
    "resistant",
    "セキュリティ",
    "暗号",
    "暗号化",
    "安全な直接通信",
    "ポスト暗号",
    "ネットワーク",
    "リピーター",
    "ハッキング",
    "サイドチャネル攻撃",
    "ビットコミットメント",
    "デジタル署名",
    "秘密共有",
    "安全な通信",
    "安全",
    "耐性",
    "安全",
    "密码学",
    "加密",
    "安全直接通信",
    "后密码学",
    "网络",
    "中继器",
    "黑客",
    "侧信道攻击",
    "比特承诺",
    "数字签名",
    "秘密共享",
    "安全通信",
    "安全",
    "抗性",
  ],
  "Quantum key distirbution ": [
    "quantum key distirbution",
    "security",
    "bb84",
    "b92",
    "single-photon QKD",
    "cryptography",
    "key distribution",
    "qkd",
    "encryption",
    "Alice",
    "Bob",
    "Eve",
    "e91",
    "entanglement-based QKD",
    "entanglement",
    "ekert protocol",
    "量子鍵配送",
    "セキュリティ",
    "bb84",
    "b92",
    "単一光子QKD",
    "暗号",
    "鍵配送",
    "qkd",
    "暗号化",
    "アリス",
    "ボブ",
    "イブ",
    "e91",
    "エンタングルメントベースのQKD",
    "エンタングルメント",
    "エッカートプロトコル",
    "量子密钥分发",
    "安全",
    "bb84",
    "b92",
    "单光子QKD",
    "密码学",
    "密钥分发",
    "qkd",
    "加密",
    "爱丽丝",
    "鲍勃",
    "伊芙",
    "e91",
    "基于纠缠的QKD",
    "纠缠",
    "埃克特协议",
  ],
  "Quantum Simulation": [
    "hamiltonian simulation",
    "wavefunction",
    "many-body systems",
    "phase transition",
    "dynamics",
    "Monte Carlo",
    "lattice models",
    "fermionic simulation",
    "bosonic simulation",
    "chemistry",
    "variational eigensolver",
    "vqe",
    "unitary coupled cluster",
    "molecular dynamics",
    "field theory",
    "digital simulation",
    "analog simulation",
    "chaos",
    "adiabatic simulation",
    "walk",
    " cellular automata",
    "ハミルトニアンシミュレーション",
    "波動関数",
    "多体システム",
    "相転移",
    "ダイナミクス",
    "モンテカルロ",
    "格子モデル",
    "フェルミオンシミュレーション",
    "ボソンシミュレーション",
    "化学",
    "変分固有値求解器",
    "vqe",
    "ユニタリー結合クラスター",
    "分子動力学",
    "場の理論",
    "デジタルシミュレーション",
    "アナログシミュレーション",
    "カオス",
    "断熱シミュレーション",
    "ウォーク",
    "セルラーオートマトン",
    "哈密顿模拟",
    "波函数",
    "多体系统",
    "相变",
    "动力学",
    "蒙特卡洛",
    "格子模型",
    "费米子模拟",
    "玻色子模拟",
    "化学",
    "变分特征值求解器",
    "vqe",
    "单元耦合簇",
    "分子动力学",
    "场论",
    "数字模拟",
    "模拟模拟",
    "混沌",
    "绝热模拟",
    "行走",
    "细胞自动机",
  ],
  "Quantum Hardware": [
    "superconducting",
    "trapped ions",
    "topological qubit",
    "decoherence",
    "error correction",
    "surface code",
    "chip",
    "Josephson junction",
    "annealer",
    "processor",
    "transducer",
    "hybrid systems",
    "memristor",
    "超伝導",
    "トラップされたイオン",
    "トポロジカルキュービット",
    "デコヒーレンス",
    "エラー修正",
    "表面コード",
    "チップ",
    "ジョセフソン接合",
    "アニーラー",
    "プロセッサ",
    "トランスデューサー",
    "ハイブリッドシステム",
    "メムリスタ",
    "超导",
    "捕获离子",
    "拓扑量子比特",
    "去相干",
    "纠错",
    "表面代码",
    "芯片",
    "约瑟夫森结",
    "退火器",
    "处理器",
    "换能器",
    "混合系统",
    "忆阻器",
  ],
  "Quantum Machine Learning": [
    "neural networks",
    "qnn",
    "support vector machine",
    "qsvm",
    "clustering",
    "principal component analysis",
    "qpca",
    "Boltzmann machine",
    "qbms",
    "generative adversarial networks",
    "qgans",
    "hybrid classical machine learning",
    "data encoding",
    "feature mapping",
    "kernel estimation",
    "unsupervised learning",
    "reinforcement learning",
    "autoencoders",
    "classifier",
    "regression",
    "data",
    "ニューラルネットワーク",
    "qnn",
    "サポートベクターマシン",
    "qsvm",
    "クラスタリング",
    "主成分分析",
    "qpca",
    "ボルツマンマシン",
    "qbms",
    "生成対抗ネットワーク",
    "qgans",
    "ハイブリッド古典機械学習",
    "データエンコーディング",
    "特徴マッピング",
    "カーネル推定",
    "教師なし学習",
    "強化学習",
    "オートエンコーダ",
    "分類器",
    "回帰",
    "データ",
    "神经网络",
    "qnn",
    "支持向量机",
    "qsvm",
    "聚类",
    "主成分分析",
    "qpca",
    "玻尔兹曼机",
    "qbms",
    "生成对抗网络",
    "qgans",
    "混合经典机器学习",
    "数据编码",
    "特征映射",
    "核估计",
    "无监督学习",
    "强化学习",
    "自动编码器",
    "分类器",
    "回归",
    "数据",
  ],
  "Quantum Communication": [
    "communication protocols",
    "coherent communication",
    "modulation",
    "communication complexity",
    "internet",
    "repeater",
    "router",
    "network",
    "channel",
    "link",
    "relay",
    "bridge",
    "satellite",
    "通信プロトコル",
    "コヒーレント通信",
    "変調",
    "通信複雑性",
    "インターネット",
    "リピーター",
    "ルーター",
    "ネットワーク",
    "チャネル",
    "リンク",
    "リレー",
    "ブリッジ",
    "衛星",
    "通信协议",
    "相干通信",
    "调制",
    "通信复杂性",
    "互联网",
    "中继器",
    "路由器",
    "网络",
    "通道",
    "链接",
    "中继",
    "桥接器",
    "卫星",
  ],
  "Quantum Computer Tooling and Frameworks": [
    "development kit",
    "QDK",
    "SDK",
    "IDE",
    "programming environment",
    "emulation",
    "design",
    "circuit optimization",
    "gate library",
    "error correction tools",
    "debugging",
    "visualization tools",
    "benchmarking",
    "hardware integration",
    "cloud service",
    "API",
    "開発キット",
    "QDK",
    "SDK",
    "IDE",
    "プログラミング環境",
    "エミュレーション",
    "設計",
    "回路最適化",
    "ゲートライブラリ",
    "エラー修正ツール",
    "デバッグ",
    "可視化ツール",
    "ベンチマーク",
    "ハードウェア統合",
    "クラウドサービス",
    "API",
    "开发套件",
    "QDK",
    "SDK",
    "IDE",
    "编程环境",
    "仿真",
    "设计",
    "电路优化",
    "门库",
    "纠错工具",
    "调试",
    "可视化工具",
    "基准测试",
    "硬件集成",
    "云服务",
    "API",
  ],
  "Quantum Computer Simulation": [
    "computing simulator",
    "computer simulation",
    "state vector simulation",
    "computer emulation",
    "circuit simulation",
    "hardware simulation",
    "system simulation",
    "software simulation",
    "virtual computer",
    "computing simulator",
    "emulator",
    "computing emulation",
    "circuit emulator",
    "state simulator",
    "gate simulator",
    "processor simulation",
    "algorithm simulation",
    "コンピューティングシミュレーター",
    "コンピュータシミュレーション",
    "状態ベクトルシミュレーション",
    "コンピュータエミュレーション",
    "回路シミュレーション",
    "ハードウェアシミュレーション",
    "システムシミュレーション",
    "ソフトウェアシミュレーション",
    "仮想コンピュータ",
    "コンピューティングシミュレーター",
    "エミュレータ",
    "コンピューティングエミュレーション",
    "回路エミュレータ",
    "状態シミュレーター",
    "ゲートシミュレーター",
    "プロセッサシミュレーション",
    "アルゴリズムシミュレーション",
    "计算模拟器",
    "计算机模拟",
    "状态矢量模拟",
    "计算机仿真",
    "电路模拟",
    "硬件模拟",
    "系统模拟",
    "软件模拟",
    "虚拟计算机",
    "计算模拟器",
    "仿真器",
    "计算仿真",
    "电路仿真器",
    "状态仿真器",
    "门仿真器",
    "处理器仿真",
    "算法模拟",
  ],
  "Learning Project": [
    "tutorial",
    "example",
    "learning project",
    "educational",
    "beginner",
    "introduction",
    "getting started",
    "hands-on",
    "course",
    "workshop",
    "training",
    "sample code",
    "demo",
    "guide",
    "instructional",
    "lesson",
    "walkthrough",
    "exercises",
    "teaching",
    "learning module",
    "チュートリアル",
    "例",
    "学習プロジェクト",
    "教育",
    "初心者",
    "イントロダクション",
    "入門",
    "ハンズオン",
    "コース",
    "ワークショップ",
    "トレーニング",
    "サンプルコード",
    "デモ",
    "ガイド",
    "指導",
    "レッスン",
    "ウォークスルー",
    "演習",
    "教育",
    "学習モジュール",
    "教程",
    "示例",
    "学习项目",
    "教育",
    "初学者",
    "介绍",
    "入门",
    "实践",
    "课程",
    "研讨会",
    "培训",
    "示例代码",
    "演示",
    "指南",
    "教学",
    "课程",
    "演练",
    "练习",
    "教学",
    "学习模块",
  ],
};

// Function to preprocess text
function preprocessText(text: string): string[] {
  const doc = nlp(text);
  const tokens = doc.terms().out("array");
  return tokens.filter(
    (token: any) => token.length > 1 && isNaN(Number(token))
  );
}

// Function to classify text based on keywords
function classifyText(
  text: string,
  keywordDict: KeywordDictionary,
  threshold: number = 0.85,
  exactMatchWeight: number = 3
): { category: string; scores: { [category: string]: number } } {
  const tokens = preprocessText(text);
  const categoryScores: { [category: string]: number } = {};

  for (const category in keywordDict) {
    categoryScores[category] = 0;
    for (const token of tokens) {
      for (const keyword of keywordDict[category]) {
        if (token === keyword) {
          categoryScores[category] += exactMatchWeight;
        } else {
          const similarity = jaroWinkler(token, keyword);
          if (similarity >= threshold) {
            categoryScores[category] += 1;
          }
        }
      }
    }
  }

  const bestCategory = Object.keys(categoryScores).reduce((a, b) =>
    categoryScores[a] > categoryScores[b] ? a : b
  );
  return { category: bestCategory, scores: categoryScores };
}

// Function to classify repositories based on comments
function classifyRepositories(
  repoCommentsFile: string,
  keywordDict: KeywordDictionary
): RepositoryResults {
  const repoComments: RepositoryComments = JSON.parse(
    fs.readFileSync(repoCommentsFile, "utf-8")
  );
  const results: RepositoryResults = {};

  for (const repoName in repoComments) {
    const comments = repoComments[repoName];
    const { category, scores } = classifyText(comments, keywordDict);

    console.log("Repo and category", repoName, category, scores);

    results[repoName] = { assignedCategory: category, categoryScores: scores };
  }

  return results;
}

// Function to write classification results to a file
function writeResultsToFile(
  results: RepositoryResults,
  outputFile: string
): void {
  fs.writeFileSync(outputFile, JSON.stringify(results, null, 2), "utf-8");
}

// Example usage
const repoCommentsFile = "./repository_comments.json";
const outputFile = "./classification-results.json";

// Measure time taken to classify repositories
console.time("Classification time");
const startTime = new Date().getTime();

const results = classifyRepositories(repoCommentsFile, keywords);
writeResultsToFile(results, outputFile);

const endTime = new Date().getTime();
console.log(
  "Classification complete. Results saved to classification-results.json"
);
// time in minutes
console.log("Time taken:", (endTime - startTime) / 1000 / 60, "minutes");
